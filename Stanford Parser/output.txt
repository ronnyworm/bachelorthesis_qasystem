(ROOT
  (NP
    (NP (NNP OpenAL) (CD 1.1))
    (NP
      (NP (NNP Specification))
      (CC and)
      (NP (NNP Reference) (CD 2.7)))
    (. .)))

root(ROOT-0, OpenAL-1)
nummod(OpenAL-1, 1.1-2)
dep(OpenAL-1, Specification-3)
cc(Specification-3, and-4)
dep(OpenAL-1, Reference-5)
conj:and(Specification-3, Reference-5)
nummod(Reference-5, 2.7-6)

(ROOT
  (S
    (NP (NNP AL) (NNPS Errors) (NNP OpenAL))
    (VP (VBZ detects)
      (NP
        (NP (RB only) (DT a) (NN subset))
        (PP (IN of)
          (NP
            (NP (DT those) (NNS conditions))
            (SBAR
              (WHNP (WDT that))
              (S
                (VP (MD could)
                  (VP (VB be)
                    (VP (VBN considered)
                      (NP (NNS errors)))))))))))
    (. .)))

compound(OpenAL-3, AL-1)
compound(OpenAL-3, Errors-2)
nsubj(detects-4, OpenAL-3)
root(ROOT-0, detects-4)
advmod(subset-7, only-5)
det(subset-7, a-6)
dobj(detects-4, subset-7)
case(conditions-10, of-8)
det(conditions-10, those-9)
nmod:of(subset-7, conditions-10)
nsubjpass(considered-14, conditions-10)
ref(conditions-10, that-11)
aux(considered-14, could-12)
auxpass(considered-14, be-13)
acl:relcl(conditions-10, considered-14)
dobj(considered-14, errors-15)

(ROOT
  (S
    (NP (DT This))
    (VP (VBZ is)
      (SBAR (IN because)
        (S
          (PP (IN in)
            (NP (JJ many) (NNS cases)))
          (NP (NN error) (NN checking))
          (VP (MD would)
            (ADVP (RB adversely))
            (VP (VB impact)
              (NP
                (NP (DT the) (NN performance))
                (PP (IN of)
                  (NP (DT an) (JJ error-free) (NN program)))))))))
    (. .)))

nsubj(is-2, This-1)
root(ROOT-0, is-2)
mark(impact-11, because-3)
case(cases-6, in-4)
amod(cases-6, many-5)
nmod:in(impact-11, cases-6)
compound(checking-8, error-7)
nsubj(impact-11, checking-8)
aux(impact-11, would-9)
advmod(impact-11, adversely-10)
advcl(is-2, impact-11)
det(performance-13, the-12)
dobj(impact-11, performance-13)
case(program-17, of-14)
det(program-17, an-15)
amod(program-17, error-free-16)
nmod:of(performance-13, program-17)

(ROOT
  (NP
    (NP (DT The) (NN command))
    (: :)
    (S
      (NP
        (NP (NNP ALenum) (NNP alGetError))
        (PRN (-LRB- -LRB-)
          (ADJP (NN void))
          (-RRB- -RRB-)))
      (VP (VBZ is)
        (VP (VBN used)
          (S
            (VP (TO to)
              (VP (VB obtain)
                (NP (NN error) (NN information))))))))
    (. .)))

det(command-2, The-1)
root(ROOT-0, command-2)
compound(alGetError-5, ALenum-4)
nsubjpass(used-10, alGetError-5)
nsubj(obtain-12, alGetError-5)
dep(alGetError-5, void-7)
auxpass(used-10, is-9)
dep(command-2, used-10)
mark(obtain-12, to-11)
xcomp(used-10, obtain-12)
compound(information-14, error-13)
dobj(obtain-12, information-14)

(ROOT
  (S
    (NP (DT Each) (JJ detectable) (NN error))
    (VP (VBZ is)
      (VP (VBN assigned)
        (NP (DT a) (JJ numeric) (NN code))))
    (. .)))

det(error-3, Each-1)
amod(error-3, detectable-2)
nsubjpass(assigned-5, error-3)
auxpass(assigned-5, is-4)
root(ROOT-0, assigned-5)
det(code-8, a-6)
amod(code-8, numeric-7)
dobj(assigned-5, code-8)

(ROOT
  (S
    (S
      (SBAR
        (WHADVP (WRB When))
        (S
          (NP (DT an) (NN error))
          (VP (VBZ is)
            (VP (VBN detected)
              (PP (IN by)
                (NP (NNP AL)))))))
      (, ,)
      (NP (DT a) (NN flag))
      (VP (VBZ is)
        (VP (VBN set))))
    (CC and)
    (S
      (NP (DT the) (NN error) (NN code))
      (VP (VBZ is)
        (VP (VBN recorded))))
    (. .)))

advmod(detected-5, When-1)
det(error-3, an-2)
nsubjpass(detected-5, error-3)
auxpass(detected-5, is-4)
advcl(set-12, detected-5)
case(AL-7, by-6)
nmod:by(detected-5, AL-7)
det(flag-10, a-9)
nsubjpass(set-12, flag-10)
auxpass(set-12, is-11)
root(ROOT-0, set-12)
cc(set-12, and-13)
det(code-16, the-14)
compound(code-16, error-15)
nsubjpass(recorded-18, code-16)
auxpass(recorded-18, is-17)
conj:and(set-12, recorded-18)

(ROOT
  (S
    (NP
      (NP (JJ Further) (NNS errors))
      (, ,)
      (SBAR (IN if)
        (S
          (NP (PRP they))
          (VP (VBP occur))))
      (, ,))
    (VP (VBP do) (RB not)
      (VP (VB affect)
        (NP (DT this) (VBN recorded) (NN code))))
    (. .)))

amod(errors-2, Further-1)
nsubj(affect-10, errors-2)
mark(occur-6, if-4)
nsubj(occur-6, they-5)
acl:relcl(errors-2, occur-6)
aux(affect-10, do-8)
neg(affect-10, not-9)
root(ROOT-0, affect-10)
det(code-13, this-11)
amod(code-13, recorded-12)
dobj(affect-10, code-13)

(ROOT
  (S
    (S
      (SBAR
        (WHADVP (WRB When))
        (S
          (NP (NN alGetError))
          (VP (VBZ is)
            (VP (VBN called)))))
      (, ,)
      (NP (DT the) (NN code))
      (VP (VBZ is)
        (VP (VBN returned))))
    (CC and)
    (S
      (NP (DT the) (NN flag))
      (VP (VBZ is)
        (VP (VBN cleared) (, ,)
          (SBAR (RB so) (IN that)
            (S
              (NP (DT a) (JJ further) (NN error))
              (VP (MD will)
                (ADVP (RB again))
                (VP (VB record)
                  (NP (PRP$ its) (NN code)))))))))
    (. .)))

advmod(called-4, When-1)
nsubjpass(called-4, alGetError-2)
auxpass(called-4, is-3)
advcl(returned-9, called-4)
det(code-7, the-6)
nsubjpass(returned-9, code-7)
auxpass(returned-9, is-8)
root(ROOT-0, returned-9)
cc(returned-9, and-10)
det(flag-12, the-11)
nsubjpass(cleared-14, flag-12)
auxpass(cleared-14, is-13)
conj:and(returned-9, cleared-14)
mark(record-23, so-16)
mwe(so-16, that-17)
det(error-20, a-18)
amod(error-20, further-19)
nsubj(record-23, error-20)
aux(record-23, will-21)
advmod(record-23, again-22)
advcl(cleared-14, record-23)
nmod:poss(code-25, its-24)
dobj(record-23, code-25)

(ROOT
  (S
    (SBAR (IN If)
      (S
        (NP (DT a) (NN call))
        (VP (TO to)
          (VP (VB alGetError)
            (NP (NNS returns) (NN AL_NO_ERROR))
            (ADVP (RB then))))))
    (NP (EX there))
    (VP (VBZ has)
      (VP
        (VP (VBN been)
          (NP
            (NP (DT no) (JJ detectable) (NN error))
            (PP (IN since)
              (NP (DT the) (JJ last) (NN call))))
          (PP (TO to)
            (NP (NN alGetError))))
        (PRN (-LRB- -LRB-)
          (CC or)
          (VP
            (ADVP (IN since)
              (NP (DT the) (NN AL)))
            (VBD was)
            (VP (VBN initialized)))
          (-RRB- -RRB-))))
    (. .)))

mark(alGetError-5, If-1)
det(call-3, a-2)
nsubj(alGetError-5, call-3)
mark(alGetError-5, to-4)
advcl(error-14, alGetError-5)
compound(AL_NO_ERROR-7, returns-6)
dobj(alGetError-5, AL_NO_ERROR-7)
advmod(alGetError-5, then-8)
expl(error-14, there-9)
aux(error-14, has-10)
cop(error-14, been-11)
neg(error-14, no-12)
amod(error-14, detectable-13)
root(ROOT-0, error-14)
case(call-18, since-15)
det(call-18, the-16)
amod(call-18, last-17)
nmod:since(error-14, call-18)
case(alGetError-20, to-19)
nmod:to(error-14, alGetError-20)
cc(initialized-27, or-22)
case(AL-25, since-23)
det(AL-25, the-24)
advmod(initialized-27, AL-25)
auxpass(initialized-27, was-26)
dep(error-14, initialized-27)

(ROOT
  (S
    (NP (NNP Error) (NNS codes))
    (VP (MD can)
      (VP (VB be)
        (VP (VBN mapped)
          (PP (TO to)
            (NP (NNS strings))))))
    (. .)))

compound(codes-2, Error-1)
nsubjpass(mapped-5, codes-2)
aux(mapped-5, can-3)
auxpass(mapped-5, be-4)
root(ROOT-0, mapped-5)
case(strings-7, to-6)
nmod:to(mapped-5, strings-7)

(ROOT
  (S
    (NP (DT The) (VBG alGetString) (NN function))
    (VP (VBZ returns)
      (NP
        (NP (DT a) (NN pointer))
        (PP (TO to)
          (NP (DT a) (JJ constant)
            (PRN (-LRB- -LRB-)
              (NP (NNP literal))
              (-RRB- -RRB-))
            (NN string)))
        (SBAR
          (WHNP (WDT that))
          (S
            (VP (VBZ is)
              (ADJP (JJ identical)
                (PP (TO to)
                  (NP
                    (NP (DT the) (NN identifier))
                    (VP (VBN used)
                      (PP (IN for)
                        (NP (DT the) (NN enumeration) (NN value)))))))
              (, ,)
              (SBAR (IN as)
                (S
                  (VP (VBN defined)
                    (PP (IN in)
                      (NP (DT the) (NN specification)))))))))))
    (. .)))

det(function-3, The-1)
amod(function-3, alGetString-2)
nsubj(returns-4, function-3)
root(ROOT-0, returns-4)
det(pointer-6, a-5)
dobj(returns-4, pointer-6)
nsubj(identical-16, pointer-6)
case(string-13, to-7)
det(string-13, a-8)
amod(string-13, constant-9)
appos(string-13, literal-11)
nmod:to(pointer-6, string-13)
ref(pointer-6, that-14)
cop(identical-16, is-15)
acl:relcl(pointer-6, identical-16)
case(identifier-19, to-17)
det(identifier-19, the-18)
nmod:to(identical-16, identifier-19)
acl(identifier-19, used-20)
case(value-24, for-21)
det(value-24, the-22)
compound(value-24, enumeration-23)
nmod:for(used-20, value-24)
mark(defined-27, as-26)
advcl(identical-16, defined-27)
case(specification-30, in-28)
det(specification-30, the-29)
nmod:in(defined-27, specification-30)

(ROOT
  (NP
    (NP (NNP Table) (CD 2.2))
    (: :)
    (S
      (NP (NNP Error) (NNP Conditions))
      (VP (VB Name)
        (NP
          (NP (NNP Description) (NNP AL_NO_ERROR))
          (SBAR
            (S
              (NP (EX There))
              (VP (VBZ is)
                (NP (DT no) (JJ current) (NN error))))))))
    (. .)))

root(ROOT-0, Table-1)
nummod(Table-1, 2.2-2)
compound(Conditions-5, Error-4)
nsubj(Name-6, Conditions-5)
parataxis(Table-1, Name-6)
compound(AL_NO_ERROR-8, Description-7)
dobj(Name-6, AL_NO_ERROR-8)
expl(is-10, There-9)
acl:relcl(AL_NO_ERROR-8, is-10)
neg(error-13, no-11)
amod(error-13, current-12)
nsubj(is-10, error-13)

(ROOT
  (S
    (NP (NNP AL_INVALID_NAME) (NNP Invalid))
    (VP (VBP name)
      (NP (NN parameter)))
    (. .)))

compound(Invalid-2, AL_INVALID_NAME-1)
nsubj(name-3, Invalid-2)
root(ROOT-0, name-3)
dobj(name-3, parameter-4)

(ROOT
  (S
    (NP (NNP AL_INVALID_ENUM) (NNP Invalid))
    (VP (VBP parameter))
    (. .)))

compound(Invalid-2, AL_INVALID_ENUM-1)
nsubj(parameter-3, Invalid-2)
root(ROOT-0, parameter-3)

(ROOT
  (S
    (NP (NNP AL_INVALID_VALUE) (NNP Invalid))
    (VP (VBP enum)
      (NP (NN parameter) (NN value)))
    (. .)))

compound(Invalid-2, AL_INVALID_VALUE-1)
nsubj(enum-3, Invalid-2)
root(ROOT-0, enum-3)
compound(value-5, parameter-4)
dobj(enum-3, value-5)

(ROOT
  (S
    (NP (NNP AL_INVALID_OPERATION) (NNP Illegal))
    (VP (VBP call))
    (. .)))

compound(Illegal-2, AL_INVALID_OPERATION-1)
nsubj(call-3, Illegal-2)
root(ROOT-0, call-3)

(ROOT
  (FRAG
    (ADJP (JJ AL_OUT_OF_MEMORY) (JJ Unable))
    (S
      (VP (TO to)
        (VP (VB allocate)
          (NP (NN memory)))))
    (. .)))

amod(Unable-2, AL_OUT_OF_MEMORY-1)
root(ROOT-0, Unable-2)
mark(allocate-4, to-3)
dep(Unable-2, allocate-4)
dobj(allocate-4, memory-5)

(ROOT
  (S
    (NP (DT The) (NN table))
    (ADVP (RB above))
    (VP (VBZ summarizes)
      (NP (DT the) (NNP AL) (NNS errors)))
    (. .)))

det(table-2, The-1)
nsubj(summarizes-4, table-2)
advmod(summarizes-4, above-3)
root(ROOT-0, summarizes-4)
det(errors-7, the-5)
compound(errors-7, AL-6)
dobj(summarizes-4, errors-7)

(ROOT
  (S
    (SBAR
      (WHADVP (WRB When))
      (S
        (NP (DT an) (NN error) (NN flag))
        (VP (VBZ is)
          (VP (VBN set)))))
    (, ,)
    (NP
      (NP (NNS results))
      (PP (IN of)
        (NP (NNP AL) (NNS operations))))
    (VP (VBP are)
      (ADJP (JJ undefined))
      (SBAR (RB only) (IN if)
        (S
          (NP (NNP AL_OUT_OF_MEMORY))
          (VP (VBZ has)
            (VP (VBN occurred))))))
    (. .)))

advmod(set-6, When-1)
det(flag-4, an-2)
compound(flag-4, error-3)
nsubjpass(set-6, flag-4)
auxpass(set-6, is-5)
advcl(undefined-13, set-6)
nsubj(undefined-13, results-8)
case(operations-11, of-9)
compound(operations-11, AL-10)
nmod:of(results-8, operations-11)
cop(undefined-13, are-12)
root(ROOT-0, undefined-13)
advmod(occurred-18, only-14)
mark(occurred-18, if-15)
nsubj(occurred-18, AL_OUT_OF_MEMORY-16)
aux(occurred-18, has-17)
advcl(undefined-13, occurred-18)

(ROOT
  (S
    (PP (IN In)
      (NP (JJ other) (NNS cases)))
    (, ,)
    (NP
      (NP (DT the) (NN command))
      (VP (VBG generating)
        (NP (DT the) (NN error))))
    (VP (VBZ is)
      (VP (VBN ignored)
        (SBAR (RB so) (IN that)
          (S
            (NP (PRP it))
            (VP (VBZ has)
              (NP
                (NP (DT no) (NN effect))
                (PP (IN on)
                  (NP (NNP AL) (NN state)
                    (CC or)
                    (NN output) (NN buffer) (NNS contents)))))))))
    (. .)))

case(cases-3, In-1)
amod(cases-3, other-2)
nmod:in(ignored-11, cases-3)
det(command-6, the-5)
nsubjpass(ignored-11, command-6)
acl(command-6, generating-7)
det(error-9, the-8)
dobj(generating-7, error-9)
auxpass(ignored-11, is-10)
root(ROOT-0, ignored-11)
mark(has-15, so-12)
mwe(so-12, that-13)
nsubj(has-15, it-14)
advcl(ignored-11, has-15)
neg(effect-17, no-16)
dobj(has-15, effect-17)
case(state-20, on-18)
compound(state-20, AL-19)
nmod:on(effect-17, state-20)
cc(state-20, or-21)
compound(contents-24, output-22)
compound(contents-24, buffer-23)
nmod:on(effect-17, contents-24)
conj:or(state-20, contents-24)

(ROOT
  (S
    (SBAR (IN If)
      (S
        (NP (DT the) (NN error) (VBG generating) (NN command))
        (VP (VBZ returns)
          (NP (DT a) (NN value)))))
    (, ,)
    (NP (PRP it))
    (VP (VBZ returns)
      (NP (CD zero)))
    (. .)))

mark(returns-6, If-1)
det(command-5, the-2)
compound(command-5, error-3)
amod(command-5, generating-4)
nsubj(returns-6, command-5)
advcl(returns-11, returns-6)
det(value-8, a-7)
dobj(returns-6, value-8)
nsubj(returns-11, it-10)
root(ROOT-0, returns-11)
dobj(returns-11, zero-12)

(ROOT
  (S
    (SBAR (IN If)
      (S
        (NP (DT the) (VBG generating) (NN command))
        (VP (VBZ modifies)
          (NP (NNS values))
          (PP (IN through)
            (NP (DT a) (NN pointer) (NN argument))))))
    (, ,)
    (NP (DT no) (NN change))
    (VP (VBZ is)
      (VP (VBN made)
        (PP (TO to)
          (NP (DT these) (NNS values)))))
    (. .)))

mark(modifies-5, If-1)
det(command-4, the-2)
amod(command-4, generating-3)
nsubj(modifies-5, command-4)
advcl(made-15, modifies-5)
dobj(modifies-5, values-6)
case(argument-10, through-7)
det(argument-10, a-8)
compound(argument-10, pointer-9)
nmod:through(modifies-5, argument-10)
neg(change-13, no-12)
nsubjpass(made-15, change-13)
auxpass(made-15, is-14)
root(ROOT-0, made-15)
case(values-18, to-16)
det(values-18, these-17)
nmod:to(made-15, values-18)

(ROOT
  (S
    (NP (DT These) (NN error) (NNS semantics))
    (VP (VBP apply)
      (ADVP (RB only))
      (PP
        (PP (TO to)
          (NP (NNP AL) (NNS errors)))
        (, ,) (RB not)
        (PP (TO to)
          (NP
            (NP (NN system) (NNS errors))
            (PP (JJ such) (IN as)
              (NP (NN memory) (NN access) (NNS errors)))))))
    (. .)))

det(semantics-3, These-1)
compound(semantics-3, error-2)
nsubj(apply-4, semantics-3)
root(ROOT-0, apply-4)
advmod(apply-4, only-5)
case(errors-8, to-6)
compound(errors-8, AL-7)
advcl:to(apply-4, errors-8)
neg(errors-13, not-10)
case(errors-13, to-11)
compound(errors-13, system-12)
nmod:to(errors-8, errors-13)
case(errors-18, such-14)
mwe(such-14, as-15)
compound(errors-18, memory-16)
compound(errors-18, access-17)
nmod:such_as(errors-13, errors-18)

(ROOT
  (S
    (NP (JJ Several) (NN error) (NN generation) (NNS conditions))
    (VP (VBP are)
      (ADJP (JJ implicit)
        (PP (IN in)
          (NP
            (NP (DT the) (NN description))
            (PP (IN of)
              (NP (DT the) (JJ various) (NNP AL) (NNS commands)))))))
    (. .)))

amod(conditions-4, Several-1)
compound(conditions-4, error-2)
compound(conditions-4, generation-3)
nsubj(implicit-6, conditions-4)
cop(implicit-6, are-5)
root(ROOT-0, implicit-6)
case(description-9, in-7)
det(description-9, the-8)
nmod:in(implicit-6, description-9)
case(commands-14, of-10)
det(commands-14, the-11)
amod(commands-14, various-12)
compound(commands-14, AL-13)
nmod:of(description-9, commands-14)

(ROOT
  (S
    (ADVP (RB First))
    (, ,)
    (SBAR (IN if)
      (S
        (NP
          (NP (DT a) (NN command))
          (SBAR
            (WHNP (WDT that))
            (S
              (VP (VBZ requires)
                (NP (DT an) (JJ enumerated) (NN value))))))
        (VP (VBZ is)
          (VP (VBN passed)
            (NP
              (NP (DT a) (NN value))
              (SBAR
                (WHNP (WDT that))
                (S
                  (VP (VBZ is) (RB not)
                    (NP
                      (NP (CD one))
                      (PP (IN of)
                        (NP
                          (NP (DT those) (VBN specified)
                            (QP (RB as) (CD allowable)))
                          (PP (IN for)
                            (NP (DT that) (NN command))))))))))))))
    (, ,)
    (NP (DT the) (NN error))
    (VP (VBZ AL_INVALID_ENUM)
      (NP (NNS results)))
    (. .)))

advmod(AL_INVALID_ENUM-30, First-1)
mark(passed-12, if-3)
det(command-5, a-4)
nsubj(requires-7, command-5)
nsubjpass(passed-12, command-5)
ref(command-5, that-6)
acl:relcl(command-5, requires-7)
det(value-10, an-8)
amod(value-10, enumerated-9)
dobj(requires-7, value-10)
auxpass(passed-12, is-11)
advcl(AL_INVALID_ENUM-30, passed-12)
det(value-14, a-13)
dobj(passed-12, value-14)
nsubj(one-18, value-14)
ref(value-14, that-15)
cop(one-18, is-16)
neg(one-18, not-17)
acl:relcl(value-14, one-18)
case(allowable-23, of-19)
det(allowable-23, those-20)
amod(allowable-23, specified-21)
advmod(allowable-23, as-22)
nmod:of(one-18, allowable-23)
case(command-26, for-24)
det(command-26, that-25)
nmod:for(allowable-23, command-26)
det(error-29, the-28)
nsubj(AL_INVALID_ENUM-30, error-29)
root(ROOT-0, AL_INVALID_ENUM-30)
dobj(AL_INVALID_ENUM-30, results-31)

(ROOT
  (S
    (NP (DT This))
    (VP (VBZ is)
      (NP (DT the) (NN case))
      (SBAR (RB even) (IN if)
        (S
          (NP (DT the) (NN argument))
          (VP (VBZ is)
            (NP
              (NP (DT a) (NN pointer))
              (PP (TO to)
                (NP (DT a) (JJ symbolic) (JJ constant))))
            (SBAR (IN if)
              (S
                (NP (DT that) (NN value))
                (VP (VBZ is) (RB not)
                  (NP
                    (NP (JJ allowable))
                    (PP (IN for)
                      (NP (DT the) (VBN given) (NN command)))))))))))
    (. .)))

nsubj(case-4, This-1)
cop(case-4, is-2)
det(case-4, the-3)
root(ROOT-0, case-4)
advmod(pointer-11, even-5)
mark(pointer-11, if-6)
det(argument-8, the-7)
nsubj(pointer-11, argument-8)
cop(pointer-11, is-9)
det(pointer-11, a-10)
advcl(case-4, pointer-11)
case(constant-15, to-12)
det(constant-15, a-13)
amod(constant-15, symbolic-14)
nmod:to(pointer-11, constant-15)
mark(allowable-21, if-16)
det(value-18, that-17)
nsubj(allowable-21, value-18)
cop(allowable-21, is-19)
neg(allowable-21, not-20)
advcl(pointer-11, allowable-21)
case(command-25, for-22)
det(command-25, the-23)
amod(command-25, given-24)
nmod:for(allowable-21, command-25)

(ROOT
  (S
    (NP (DT This))
    (VP (MD will)
      (VP (VB occur)
        (SBAR (IN whether)
          (S
            (NP (DT the) (NN value))
            (VP (VBZ is)
              (NP
                (NP
                  (NP (JJ allowable))
                  (PP (IN for)
                    (NP (JJ other) (NNS functions))))
                (, ,)
                (CC or)
                (NP (DT an)
                  (ADJP (JJ invalid) (JJ integer))
                  (NN value))))))))
    (. .)))

nsubj(occur-3, This-1)
aux(occur-3, will-2)
root(ROOT-0, occur-3)
mark(allowable-8, whether-4)
det(value-6, the-5)
nsubj(allowable-8, value-6)
cop(allowable-8, is-7)
ccomp(occur-3, allowable-8)
case(functions-11, for-9)
amod(functions-11, other-10)
nmod:for(allowable-8, functions-11)
cc(allowable-8, or-13)
det(value-17, an-14)
amod(integer-16, invalid-15)
amod(value-17, integer-16)
ccomp(occur-3, value-17)
conj:or(allowable-8, value-17)

(ROOT
  (S
    (NP
      (NP (CD 16) (NNP Integer) (NNS parameters))
      (SBAR
        (WHNP (WDT that))
        (S
          (VP (VBP are)
            (VP (VBN used)
              (PP (IN as)
                (NP
                  (NP (NNS names))
                  (PP (IN for)
                    (NP
                      (NP (JJ OpenAL) (NNS objects))
                      (PP (JJ such) (IN as)
                        (NP (NNS buffers)
                          (CC and)
                          (NNS sources))))))))))))
    (VP (VBP are)
      (VP (VBN checked)
        (PP (IN for)
          (NP (NN validity)))))
    (. .)))

nummod(parameters-3, 16-1)
compound(parameters-3, Integer-2)
nsubjpass(used-6, parameters-3)
nsubjpass(checked-18, parameters-3)
ref(parameters-3, that-4)
auxpass(used-6, are-5)
acl:relcl(parameters-3, used-6)
case(names-8, as-7)
nmod:as(used-6, names-8)
case(objects-11, for-9)
amod(objects-11, OpenAL-10)
nmod:for(names-8, objects-11)
case(buffers-14, such-12)
mwe(such-12, as-13)
nmod:such_as(objects-11, buffers-14)
cc(buffers-14, and-15)
nmod:such_as(objects-11, sources-16)
conj:and(buffers-14, sources-16)
auxpass(checked-18, are-17)
root(ROOT-0, checked-18)
case(validity-20, for-19)
nmod:for(checked-18, validity-20)

(ROOT
  (S
    (S
      (SBAR (IN If)
        (S
          (NP (DT an) (JJ invalid) (NN name) (NN parameter))
          (VP (VBZ is)
            (VP (VBN specified)
              (PP (IN in)
                (NP (DT an) (NNP OpenAL) (NN command)))))))
      (, ,)
      (NP (DT an) (NNP AL_INVALID_NAME) (NN error))
      (VP (MD will)
        (VP (VB be)
          (VP (VBN generated)))))
    (CC and)
    (S
      (NP (DT the) (NN command))
      (VP (VBZ is)
        (VP (VBN ignored))))
    (. .)))

mark(specified-7, If-1)
det(parameter-5, an-2)
amod(parameter-5, invalid-3)
compound(parameter-5, name-4)
nsubjpass(specified-7, parameter-5)
auxpass(specified-7, is-6)
advcl(generated-18, specified-7)
case(command-11, in-8)
det(command-11, an-9)
compound(command-11, OpenAL-10)
nmod:in(specified-7, command-11)
det(error-15, an-13)
compound(error-15, AL_INVALID_NAME-14)
nsubjpass(generated-18, error-15)
aux(generated-18, will-16)
auxpass(generated-18, be-17)
root(ROOT-0, generated-18)
cc(generated-18, and-19)
det(command-21, the-20)
nsubjpass(ignored-23, command-21)
auxpass(ignored-23, is-22)
conj:and(generated-18, ignored-23)

(ROOT
  (S
    (NP (DT An) (NN attempt)
      (S
        (VP (TO to)
          (VP (VB set)
            (NP
              (NP (JJ integral)
                (CC or)
                (JJ floating) (NN point) (NNS values))
              (PP (RB out) (IN of)
                (NP (DT the) (JJ specified) (NN range))))))))
    (VP (MD will)
      (VP (VB result)
        (PP (IN in)
          (NP (DT the) (NN error) (NN AL_INVALID_VALUE)))))
    (. .)))

det(attempt-2, An-1)
nsubj(result-16, attempt-2)
mark(set-4, to-3)
acl(attempt-2, set-4)
amod(values-9, integral-5)
cc(integral-5, or-6)
conj:or(integral-5, floating-7)
amod(values-9, floating-7)
compound(values-9, point-8)
dobj(set-4, values-9)
case(range-14, out-10)
mwe(out-10, of-11)
det(range-14, the-12)
amod(range-14, specified-13)
nmod:out_of(values-9, range-14)
aux(result-16, will-15)
root(ROOT-0, result-16)
case(AL_INVALID_VALUE-20, in-17)
det(AL_INVALID_VALUE-20, the-18)
compound(AL_INVALID_VALUE-20, error-19)
nmod:in(result-16, AL_INVALID_VALUE-20)

(ROOT
  (S
    (NP (DT The) (NN specification))
    (VP (VBZ does) (RB not)
      (VP (VB guarantee)
        (SBAR (IN that)
          (S
            (NP (DT the) (NN implementation) (NNS emits))
            (VP (VBP AL_INVALID_VALUE)
              (SBAR (IN if)
                (S
                  (NP (DT a) (NN NaN)
                    (CC or)
                    (NN infinity) (NN value))
                  (VP (VBZ is)
                    (VP (VBN passed)
                      (PP (IN in) (IN for)
                        (NP
                          (NP (DT a) (NN float))
                          (CC or)
                          (NP
                            (NP (VB double) (NN argument))
                            (PRN (-LRB- -LRB-)
                              (SBAR (IN as)
                                (S
                                  (NP (DT the) (NN specification))
                                  (VP (VBZ does) (RB not)
                                    (VP (VB enforce)
                                      (NP
                                        (NP (RB possibly) (JJ expensive) (NN testing))
                                        (PP (IN of)
                                          (NP (VBG floating) (NN point) (NNS values))))))))
                              (-RRB- -RRB-))))))))))))))
    (. .)))

det(specification-2, The-1)
nsubj(guarantee-5, specification-2)
aux(guarantee-5, does-3)
neg(guarantee-5, not-4)
root(ROOT-0, guarantee-5)
mark(AL_INVALID_VALUE-10, that-6)
det(emits-9, the-7)
compound(emits-9, implementation-8)
nsubj(AL_INVALID_VALUE-10, emits-9)
ccomp(guarantee-5, AL_INVALID_VALUE-10)
mark(passed-18, if-11)
det(value-16, a-12)
compound(value-16, NaN-13)
cc(NaN-13, or-14)
conj:or(NaN-13, infinity-15)
compound(value-16, infinity-15)
nsubjpass(passed-18, value-16)
auxpass(passed-18, is-17)
advcl(AL_INVALID_VALUE-10, passed-18)
case(float-22, in-19)
case(float-22, for-20)
det(float-22, a-21)
nmod:for(passed-18, float-22)
cc(float-22, or-23)
dep(argument-25, double-24)
nmod:for(passed-18, argument-25)
conj:or(float-22, argument-25)
mark(enforce-32, as-27)
det(specification-29, the-28)
nsubj(enforce-32, specification-29)
aux(enforce-32, does-30)
neg(enforce-32, not-31)
dep(argument-25, enforce-32)
advmod(testing-35, possibly-33)
amod(testing-35, expensive-34)
dobj(enforce-32, testing-35)
case(values-39, of-36)
amod(values-39, floating-37)
compound(values-39, point-38)
nmod:of(testing-35, values-39)

(ROOT
  (S
    (NP (NNS Commands))
    (VP (MD can)
      (VP (VB be)
        (ADJP (JJ invalid))))
    (. .)))

nsubj(invalid-4, Commands-1)
aux(invalid-4, can-2)
cop(invalid-4, be-3)
root(ROOT-0, invalid-4)

(ROOT
  (S
    (PP (IN For)
      (NP (NN example)))
    (, ,)
    (NP (JJ certain) (NNS commands))
    (VP (MD might) (RB not)
      (VP (VB be)
        (ADJP (JJ applicable)
          (PP (TO to)
            (NP (DT a) (VBN given) (NN object))))))
    (. .)))

case(example-2, For-1)
nmod:for(applicable-9, example-2)
amod(commands-5, certain-4)
nsubj(applicable-9, commands-5)
aux(applicable-9, might-6)
neg(applicable-9, not-7)
cop(applicable-9, be-8)
root(ROOT-0, applicable-9)
case(object-13, to-10)
det(object-13, a-11)
amod(object-13, given-12)
nmod:to(applicable-9, object-13)

(ROOT
  (S
    (NP (EX There))
    (VP (VBP are)
      (ADVP (RB also))
      (NP
        (NP (JJ illegal) (NNS combinations))
        (PP (IN of)
          (NP (NNS tokens)
            (CC and)
            (NNS values))))
      (PP (IN as)
        (NP (NNS arguments)))
      (PP (TO to)
        (NP (DT a) (NN command))))
    (. .)))

expl(are-2, There-1)
root(ROOT-0, are-2)
advmod(are-2, also-3)
amod(combinations-5, illegal-4)
nsubj(are-2, combinations-5)
case(tokens-7, of-6)
nmod:of(combinations-5, tokens-7)
cc(tokens-7, and-8)
nmod:of(combinations-5, values-9)
conj:and(tokens-7, values-9)
case(arguments-11, as-10)
nmod:as(are-2, arguments-11)
case(command-14, to-12)
det(command-14, a-13)
nmod:to(are-2, command-14)

(ROOT
  (S
    (NP (NNP OpenAL))
    (VP (VBZ responds)
      (PP (TO to)
        (NP
          (NP (DT any) (JJ such) (JJ illegal) (NN command))
          (PP (IN with)
            (NP (DT an) (NNP AL_INVALID_OPERATION) (NN error))))))
    (. .)))

nsubj(responds-2, OpenAL-1)
root(ROOT-0, responds-2)
case(command-7, to-3)
det(command-7, any-4)
amod(command-7, such-5)
amod(command-7, illegal-6)
nmod:to(responds-2, command-7)
case(error-11, with-8)
det(error-11, an-9)
compound(error-11, AL_INVALID_OPERATION-10)
nmod:with(command-7, error-11)

(ROOT
  (S
    (SBAR (IN If)
      (S
        (NP (NN memory))
        (VP (VBZ is)
          (VP (VBN exhausted)
            (PP (IN as)
              (NP
                (NP (DT a) (NN side) (NN effect))
                (PP (IN of)
                  (NP
                    (NP (DT the) (NN execution))
                    (PP (IN of)
                      (NP (DT an) (NNP AL) (NN command)))))
                (, ,)
                (PP (DT either)
                  (PP (IN on)
                    (NP (NN system) (NN level)))
                  (CC or)
                  (PP (IN by)
                    (S
                      (VP (VBG exhausting)
                        (NP (DT the) (VBN allocated) (NNS resources))
                        (PP (IN at)
                          (NP
                            (NP (NNP AL) (POS 's))
                            (JJ internal) (NN disposal)))))))))))))
    (, ,)
    (NP (DT the) (NN error) (NN AL_OUT_OF_MEMORY))
    (VP (MD may)
      (VP (VB be)
        (VP (VBN generated))))
    (. .)))

mark(exhausted-4, If-1)
nsubjpass(exhausted-4, memory-2)
auxpass(exhausted-4, is-3)
advcl(generated-38, exhausted-4)
case(effect-8, as-5)
det(effect-8, a-6)
compound(effect-8, side-7)
nmod:as(exhausted-4, effect-8)
case(execution-11, of-9)
det(execution-11, the-10)
nmod:of(effect-8, execution-11)
case(command-15, of-12)
det(command-15, an-13)
compound(command-15, AL-14)
nmod:of(execution-11, command-15)
cc:preconj(level-20, either-17)
case(level-20, on-18)
compound(level-20, system-19)
acl:on(effect-8, level-20)
cc(level-20, or-21)
mark(exhausting-23, by-22)
acl:on(effect-8, exhausting-23)
conj:or(level-20, exhausting-23)
det(resources-26, the-24)
amod(resources-26, allocated-25)
dobj(exhausting-23, resources-26)
case(disposal-31, at-27)
nmod:poss(disposal-31, AL-28)
case(AL-28, 's-29)
amod(disposal-31, internal-30)
nmod:at(exhausting-23, disposal-31)
det(AL_OUT_OF_MEMORY-35, the-33)
compound(AL_OUT_OF_MEMORY-35, error-34)
nsubjpass(generated-38, AL_OUT_OF_MEMORY-35)
aux(generated-38, may-36)
auxpass(generated-38, be-37)
root(ROOT-0, generated-38)

(ROOT
  (S
    (NP (DT This))
    (VP
      (VP (MD can)
        (ADVP (RB also))
        (VP (VB happen)
          (NP
            (NP (JJ independent))
            (PP (IN of)
              (NP (JJ recent) (NNS commands))))
          (SBAR (IN if)
            (S
              (NP (NNP OpenAL))
              (VP (VBZ has)
                (S
                  (VP (TO to)
                    (VP (VB request)
                      (NP (NN memory))
                      (PP (IN for)
                        (NP (DT an) (JJ internal) (NN task)))))))))))
      (CC and)
      (VP (VBZ fails)
        (S
          (VP (TO to)
            (VP (VB allocate)
              (NP (DT the) (VBN required) (NN memory))
              (PP (IN from)
                (NP (DT the) (VBG operating) (NN system))))))))
    (. .)))

nsubj(happen-4, This-1)
nsubj(fails-20, This-1)
nsubj(allocate-22, This-1)
aux(happen-4, can-2)
advmod(happen-4, also-3)
root(ROOT-0, happen-4)
dobj(happen-4, independent-5)
case(commands-8, of-6)
amod(commands-8, recent-7)
nmod:of(independent-5, commands-8)
mark(has-11, if-9)
nsubj(has-11, OpenAL-10)
nsubj(request-13, OpenAL-10)
advcl(happen-4, has-11)
mark(request-13, to-12)
xcomp(has-11, request-13)
dobj(request-13, memory-14)
case(task-18, for-15)
det(task-18, an-16)
amod(task-18, internal-17)
nmod:for(request-13, task-18)
cc(happen-4, and-19)
conj:and(happen-4, fails-20)
mark(allocate-22, to-21)
xcomp(fails-20, allocate-22)
det(memory-25, the-23)
amod(memory-25, required-24)
dobj(allocate-22, memory-25)
case(system-29, from-26)
det(system-29, the-27)
amod(system-29, operating-28)
nmod:from(allocate-22, system-29)

(ROOT
  (S
    (ADVP (RB Otherwise))
    (NP (NNS errors))
    (VP (VBP are)
      (VP (VBN generated)
        (ADVP (RB only))
        (PP (IN for)
          (NP
            (NP (NNS conditions))
            (SBAR
              (WHNP (WDT that))
              (S
                (VP (VBP are)
                  (ADVP (RB explicitly))
                  (VP (VBN described)
                    (PP (IN in)
                      (NP (DT this) (NN specification)))))))))))
    (. .)))

advmod(generated-4, Otherwise-1)
nsubjpass(generated-4, errors-2)
auxpass(generated-4, are-3)
root(ROOT-0, generated-4)
advmod(generated-4, only-5)
case(conditions-7, for-6)
nmod:for(generated-4, conditions-7)
nsubjpass(described-11, conditions-7)
ref(conditions-7, that-8)
auxpass(described-11, are-9)
advmod(described-11, explicitly-10)
acl:relcl(conditions-7, described-11)
case(specification-14, in-12)
det(specification-14, this-13)
nmod:in(described-11, specification-14)

